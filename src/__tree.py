#!/usr/bin/env python3
import fcntl
import logging
import sys

import numpy as np
import pandas as pd

import defopt
import src.dot
import src.halo
import src.read

logging.basicConfig(level=logging.DEBUG)


def build(i, data):
    """Generates merger tree from tabular data.

    Recursively generates a merger tree of the format::

        [1, [[2, []], [3, [[4, []], [5, []]]], [6, []]]]

    equivalent to::

        1
            2
            3
                4
                5
            6

    :param int i: ``nodeIndex`` of the starting halo
    :param numpy.ndarray data: dataset provided by :mod:`src.read` module
    :return List[int, List[]]: merger tree in a deeply mebedded format, rooted at
        the starting halo
    """

    h = src.halo.get(i, data)
    if not src.halo.is_host(h, data):
        raise ValueError("Not a host halo!")

    progenitors = np.unique(
        [prog for prog in d[d["descendantHost"] == h["nodeIndex"]]["hostIndex"]]
    )

    logging.debug(
        "Reached halo %d with %d progenitor(s)"
        % (h["nodeIndex"], len(progenitors))
    )

    return [
        h["nodeIndex"],
        []
        if len(progenitors) == 0
        else [build(progenitor, data) for progenitor in progenitors],
    ]


def flatten(tree):
    """Finds all ``nodeIndex`` values belonging to a given merger tree

    **Reference:** https://stackoverflow.com/a/2158532

    :param List[int, List[]] tree: merger tree generated by :func:`build`
    :return generator: flattened N-D list
    """

    for node in tree:
        try:
            for subnode in flatten(node):
                yield subnode
        except:
            yield node


def cmh(tree, data, m0, nfw_f):
    """Calculates mass assembly history from a given merger tree.

    :param List[int, List[]] tree: merger tree, generated by :func:`tree`
    :param numpy.ndarray data: dataset provided by :mod:`src.read` module
    :param int m0: mass of the root halo
    :param float nfw_f: NFW :math:`f` parameter
    :return numpy.ndarray: MAH with rows formatted like ``[nodeIndex,
        snapshotNumber, sum(particleNumber)]``
    """

    cmh = []
    progs = np.array([src.halo.get(i, data) for i in flatten(tree)])
    root = src.halo.get(tree[0], progs)

    for snap in np.unique(progs["snapshotNumber"]):
        sum_m = 0
        for h in progs[progs["snapshotNumber"] == snap]:
            m = src.halo.mass(h, data)
            if m > nfw_f * m0:
                sum_m += m
        cmh.append([root["nodeIndex"], snap, sum_m])
    return np.array(cmh)


def main(file, halo_ids, nfw_f=0.02):
    """Build merger tree & CMH of a given DHalo.

    :param str file: data file, HDF5 or NumPy cache
    :param list[int] halo_ids: list of haloes to process
    :param float nfw_f: NFW ``f`` parameter
    """

    d = src.read.retrieve(file)

    def process(i, d):
        h = src.halo.get(i, d)
        m0 = src.halo.mass(h, d)
        t = build(i, d)
        logging.info("Built a tree for halo %d" % h["nodeIndex"])
        m = cmh(t, d, m0, nfw_f)
        logging.info("Calculated CMH for halo %d" % h["nodeIndex"])
        return m

    pd.concat(
        map(
            lambda halo_id: pd.DataFrame(
                process(halo_id, d),
                columns=["nodeIndex", "snapshotNumber", "particleNumber"],
            ).set_index("nodeIndex"),
            halo_ids,
        )
    ).pivot_table(
        index="nodeIndex",
        values="particleNumber",
        columns="snapshotNumber",
        fill_value=0,
    ).to_csv(
        sys.stdout, index=True, index_label="nodeIndex"
    )


if __name__ == "__main__":
    defopt.run(main, short={"halo_ids": "H"})
