#!/usr/bin/env python
import sys
import fcntl
import logging
import defopt
import numpy as np
import pandas as pd

import src.read
import src.halo
import src.dot


def build(i, data):
    """Generates merger tree from tabular data.

    Recursively generates a merger tree of the format::

        [1, [[2, []], [3, [[4, []], [5, []]]], [6, []]]]

    equivalent to::

        1
            2
            3
                4
                5
            6

    :param int i: ``nodeIndex`` of the starting halo
    :param numpy.ndarray data: dataset provided by :mod:`src.read` module
    :return List[int, List[]]: merger tree in a deeply mebedded format, rooted at
        the starting halo
    """

    if not src.halo.is_host(i, data): raise ValueError("Not a host halo!")

    h = src.halo.get(i, data)
    progenitors = src.halo.progenitors(h, data)
    logging.debug("Reached halo %d with %d progenitor(s)" % (h["nodeIndex"],
                                                             len(progenitors)))
    return [
        h['nodeIndex'], [] if len(progenitors) == 0 else
        [build(progenitor, data) for progenitor in progenitors]
    ]


def flatten(tree):
    """Finds all ``nodeIndex`` values belonging to a given merger tree

    **Reference:** https://stackoverflow.com/a/2158532

    :param List[int, List[]] tree: merger tree generated by :func:`build`
    :return generator: flattened N-D list
    """

    for node in tree:
        try:
            for subnode in flatten(node):
                yield subnode
        except:
            yield node


def mah(tree, progs, data, m0, nfw_f):
    """Calculates mass assembly history from a given merger tree.

    :param List[int, List[]] tree: merger tree, generated by :func:`tree`
    :param numpy.ndarray progs: all prigenitors of the root halo in a merger tree
        (effectively a flattened tree), calculated by :func:`flatten`, a subset of ``data``
    :param numpy.ndarray data: dataset provided by :mod:`src.read` module
    :param int m0: mass of the root halo
    :param float nfw_f: NFW :math:`f` parameter
    :return numpy.ndarray: MAH with rows formatted like ``[nodeIndex,
        snapshotNumber, sum(particleNumber)]``
    """

    mah = []
    root = src.halo.get(tree[0], progs)

    for snap in np.unique(progs['snapshotNumber']):
        sum_m = 0
        for h in progs[progs['snapshotNumber'] == snap]:
            m = src.halo.mass(h, data)
            if m > nfw_f * m0:
                sum_m += m
        mah.append([root['nodeIndex'], snap, sum_m])
    return np.array(mah)


def main(file, haloes, nfw_f=0.02):
    """Build merger tree & CMH of a given DHalo.

    :param str file: data file, HDF5 or NumPy cache
    :param list[int] haloes: list of haloes to process
    :param float nfw_f: NFW ``f`` parameter
    """

    d = src.read.retrieve(file)

    def process(h, d):
        h = src.halo.get(h, d)
        m0 = src.halo.mass(h, d)
        t = build(h, d)
        ps = np.array([src.halo.get(i, d) for i in list(flatten(t))])
        m = mah(t, ps, d, m0, nfw_f)
        logging.info("Built a tree rooted at halo %d with %d children" %
                     (h['nodeIndex'], ps.shape[0]))
        return m

    pd.concat(
        map(lambda h:
            pd.DataFrame(
                process(h, d),
                columns=['nodeIndex', 'snapshotNumber', 'particleNumber'])\
            .set_index('nodeIndex'),
            haloes))\
        .pivot_table(
            index='nodeIndex',
            values='particleNumber',
            columns='snapshotNumber',
            fill_value=0,
        )\
        .to_csv(sys.stdout, index=True, index_label='nodeIndex')


if __name__ == '__main__':
    defopt.run(main, short={'haloes': 'H'})
